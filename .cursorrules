# Cursor Rules per DaDude Project

## Principi Fondamentali

1. **NON MODIFICARE CODICE FUNZIONANTE**
   - Se qualcosa funziona, NON toccarlo
   - Prima di modificare, verificare SE è davvero necessario
   - Se l'utente dice "funzionava prima", REVERT alle modifiche invece di aggiungere fix

2. **SEMPLICITÀ PRIMA DI TUTTO**
   - La soluzione più semplice è sempre la migliore
   - Se c'è una soluzione semplice (es: usare sempre Debian), NON cercare di supportare alternative
   - Evitare "feature creep" - non aggiungere funzionalità non richieste

3. **COMPRENDERE PRIMA DI MODIFICARE**
   - Leggere TUTTO il codice rilevante prima di modificare
   - Capire PERCHÉ qualcosa non funziona prima di aggiungere fix
   - Se l'utente dice "funzionava con X", usare X invece di cercare alternative

4. **NON INSISTERE SU SOLUZIONI COMPLESSE**
   - Se una soluzione non funziona dopo 2-3 tentativi, cambiare approccio
   - Se l'utente dice "non funziona", NON aggiungere più complessità
   - Chiedere all'utente cosa funzionava prima invece di indovinare

5. **TESTARE PRIMA DI COMMITTARE**
   - Non fare commit multipli per la stessa cosa
   - Se qualcosa non funziona, REVERT invece di aggiungere più fix
   - Un commit che rompe qualcosa è peggio di nessun commit

## Regole Specifiche per Install Scripts

- **Template/Immagine**: Se l'utente dice "funzionava con Debian", usare SEMPRE Debian
- **Repository Docker**: Usare sempre Debian repository, NON cercare di rilevare Ubuntu/Debian
- **AppArmor**: NON aggiungere configurazioni AppArmor a meno che non sia esplicitamente richiesto
- **Docker daemon.json**: Mantenere minimo, solo storage-driver se necessario
- **Fallback**: Se qualcosa fallisce, usare la versione che funzionava prima

## Regole per Database/Backend

- **Foreign Keys**: Se customer_id può essere NULL, gestirlo come None, NON come stringa vuota
- **Migration**: Testare sempre le migration su dati reali prima di applicare
- **PostgreSQL**: Verificare che tutte le query siano compatibili con PostgreSQL

## Regole per Agent Registration

- **customer_id vuoto**: Convertire sempre in None, mai stringa vuota
- **Auto-approval**: Verificare che DADUDE_DEFAULT_CUSTOMER_ID sia None se vuoto
- **Token**: Gestire correttamente token encryption/decryption

## Regole CRITICHE per Agent Connection e Stabilità

### ⚠️ CODICE FUNZIONANTE - NON MODIFICARE MAI

**SEZIONI CRITICHE CHE FUNZIONANO - NON TOCCARE:**

1. **WebSocket Connection (`dadude-agent/app/connection/ws_client.py`)**:
   - ✅ `_create_ssl_context()`: Gestisce SSL/mTLS correttamente
   - ✅ `_reconnect()`: Auto-reconnect funziona
   - ✅ **NON modificare** la logica SSL se gli agent si connettono
   - ✅ **NON modificare** la gestione dei certificati self-signed se funziona

2. **Agent Restart (`dadude-agent/app/commands/handler.py`)**:
   - ✅ `_update_agent_internal()`: Supporta sia `docker compose` che `docker-compose`
   - ✅ `_daily_restart()`: Riavvio giornaliero funziona
   - ✅ **NON modificare** la logica di restart se funziona
   - ✅ **NON cambiare** i comandi docker compose se funzionano

3. **Server WebSocket Hub (`dadude/app/services/websocket_hub.py`)**:
   - ✅ Gestione connessioni agent funziona
   - ✅ Auto-disconnect handling funziona
   - ✅ **NON modificare** se gli agent si riconnettono correttamente

4. **Agent Auto-Probe (`dadude/app/services/agent_service.py`)**:
   - ✅ Prova SSH anche senza porta 22 rilevata se ci sono credenziali
   - ✅ **NON modificare** questa logica se funziona

### Regole per Modifiche Future

- **PRIMA di modificare codice agent/server connection**:
  1. Verificare che il problema sia reale e non un falso positivo
  2. Chiedere conferma esplicita all'utente
  3. Testare su ambiente di sviluppo PRIMA di applicare
  4. Creare un tag Git stabile PRIMA di modificare
  5. Documentare la modifica nelle cursorrules

- **Se un agent si disconnette dopo una modifica**:
  1. **REVERT immediatamente** alle modifiche
  2. Verificare che il tag stabile funzioni ancora
  3. Non aggiungere "fix" su "fix" - meglio revert completo

- **Versioning Stabile**:
  - Usare tag Git per versioni stabili (es: `v2.3.13-stable`)
  - Gli agent devono poter essere configurati per usare un tag specifico
  - Non forzare auto-update a `main` se non esplicitamente richiesto

## Regole per Aggiornamento Server Locale

### ⚠️ SERVER PCT 600 - AGGIORNAMENTO OBBLIGATORIO

**Server Locale di Sviluppo/Test:**
- **Host**: 192.168.40.1
- **Container**: PCT 600 (Proxmox)
- **Container Docker**: `dadude`
- **Path codice**: `/app/repo` nel container

**REGOLE CRITICHE:**

1. **DOPO OGNI MODIFICA AL CODICE**:
   - ✅ Committare le modifiche su git
   - ✅ Pushare su `origin/main`
   - ✅ **AGGIORNARE IMMEDIATAMENTE** il server PCT 600 con:
     ```bash
     # Metodo 1: Script helper (consigliato)
     ./update-server-pct600.sh
     
     # Metodo 2: Comando manuale
     ssh root@192.168.40.1 "pct exec 600 -- bash -c 'docker exec dadude bash -c \"git config --global --add safe.directory /app/repo && cd /app/repo && git pull origin main && exit\"' && docker restart dadude"
     ```
   - ✅ Verificare che il container si sia riavviato correttamente
   - ✅ Verificare che le modifiche siano presenti nel codice del server

2. **PRIMA DI TESTARE FUNZIONALITÀ**:
   - ✅ Verificare che il server sia aggiornato all'ultimo commit
   - ✅ Se il server non è aggiornato, aggiornarlo PRIMA di testare
   - ✅ Non testare funzionalità su codice non aggiornato

3. **WORKFLOW STANDARD**:
   ```
   Modifica codice → Commit → Push → Aggiorna PCT 600 → Verifica → Test
   ```

4. **VERIFICA AGGIORNAMENTO**:
   - Controllare ultimo commit: `git log -1` nel container
   - Verificare che le modifiche siano presenti nel codice
   - Controllare log del container dopo riavvio

**NON FARE MAI:**
- ❌ Committare modifiche senza aggiornare il server
- ❌ Testare funzionalità su server non aggiornato
- ❌ Lasciare il server con codice obsoleto dopo modifiche

## Workflow Consigliato

1. **Leggere** il codice esistente e capire come funziona
2. **Identificare** il problema reale (non quello che pensi sia)
3. **Proporre** la soluzione più semplice possibile
4. **Testare** prima di commitare
5. **Committare e pushare** le modifiche
6. **Aggiornare server PCT 600** (192.168.40.1, container 600)
7. **Verificare** che le modifiche siano applicate
8. **Se non funziona**: REVERT e riprovare con approccio diverso

## Cosa NON Fare

- ❌ NON aggiungere configurazioni complesse "per sicurezza"
- ❌ NON cercare di supportare più opzioni quando una funziona
- ❌ NON fare commit multipli per la stessa cosa
- ❌ NON aggiungere "fix" su "fix" - meglio revert e ripartire
- ❌ NON modificare codice funzionante "per migliorarlo"
- ❌ NON aggiungere feature non richieste dall'utente
- ❌ **MAI modificare codice che funziona** - Se un sistema funziona, NON toccarlo
- ❌ **MAI modificare la logica di connessione agent** se funziona correttamente
- ❌ **MAI modificare SSL/mTLS** se gli agent si connettono senza problemi
- ❌ **MAI modificare docker compose/restart logic** se funziona
- ❌ **MAI modificare auto-update logic** se funziona - solo se esplicitamente richiesto

## Cosa Fare

- ✅ Chiedere all'utente cosa funzionava prima
- ✅ Usare sempre la soluzione più semplice
- ✅ Testare prima di commitare
- ✅ REVERT se qualcosa si rompe
- ✅ Mantenere il codice semplice e leggibile
- ✅ Seguire il principio KISS (Keep It Simple, Stupid)
- ✅ **PRIMA di modificare codice funzionante**: chiedere conferma esplicita all'utente
- ✅ **PRIMA di modificare logica agent**: verificare che sia davvero necessario
- ✅ **PRIMA di modificare SSL/WebSocket**: verificare che il problema non sia altrove
- ✅ **Se l'utente dice "funzionava prima"**: REVERT immediatamente alle modifiche
- ✅ **Usare tag Git stabili** per versioni funzionanti degli agent
- ✅ **Documentare** ogni modifica critica (SSL, connessione, restart) nelle cursorrules
- ✅ **DOPO OGNI MODIFICA**: Committare, pushare e aggiornare IMMEDIATAMENTE il server PCT 600 (192.168.40.1)
- ✅ **PRIMA DI TESTARE**: Verificare che il server PCT 600 sia aggiornato all'ultimo commit

## Organizzazione Struttura Progetto

### Separazione Cartelle e Moduli

1. **Moduli/Componenti**
   - Mantenere moduli separati per funzionalità distinte
   - Ogni modulo nella sua directory dedicata
   - Evitare di mescolare logiche diverse nello stesso file
   - Usare struttura modulare chiara (es: `app/routers/`, `app/services/`, `app/models/`)

2. **Script**
   - Script di installazione: `deploy/` o `scripts/install/`
   - Script di utilità: `scripts/` o `tools/`
   - Script di migrazione: `migrations/` o `scripts/migrate/`
   - NON mettere script nella root del progetto
   - Ogni script deve avere uno scopo chiaro e documentato

3. **Test**
   - Test unitari: `tests/unit/` o `tests/`
   - Test di integrazione: `tests/integration/`
   - Test E2E: `tests/e2e/`
   - NON mescolare test con codice sorgente
   - Mantenere test separati per ogni modulo

4. **Documentazione**
   - Documentazione generale: `docs/` o `documentation/`
   - README: nella root del progetto o del modulo
   - Guide di installazione: `docs/install/` o `INSTALL.md`
   - API docs: `docs/api/` o generati automaticamente
   - NON mettere documentazione sparsa nella root

5. **HTML/Frontend**
   - Frontend Vue/React: `frontend/` o `web/`
   - Template HTML: `templates/` o `frontend/templates/`
   - Assets statici: `static/` o `frontend/static/`
   - NON mescolare HTML con codice backend

6. **Backup**
   - Backup database: `backups/` o `data/backups/`
   - Backup configurazioni: `backups/config/`
   - Script di backup: `scripts/backup/`
   - NON committare backup nel repository (usare .gitignore)
   - Mantenere backup temporanei fuori dal repository

7. **Configurazione**
   - File di config: `config/` o nella root con nome chiaro (`.env.example`)
   - Config per ambiente: `config/dev/`, `config/prod/`
   - NON hardcodare configurazioni nel codice
   - Usare variabili d'ambiente o file di config separati

8. **Log e Dati Temporanei**
   - Log: `logs/` o `var/log/` (NON committare)
   - Dati temporanei: `tmp/` o `var/tmp/` (NON committare)
   - Cache: `cache/` o `var/cache/` (NON committare)
   - Aggiungere a `.gitignore` tutti i file temporanei

9. **Build e Distribuzione**
   - Build artifacts: `dist/` o `build/` (NON committare)
   - Dockerfiles: nella root o `docker/`
   - Docker compose: nella root o `deploy/docker/`
   - Script di deploy: `deploy/` o `scripts/deploy/`

### Regole di Organizzazione

- ✅ Mantenere struttura chiara e coerente
- ✅ Separare sempre codice, test, documentazione, script
- ✅ Usare nomi di directory descrittivi e standard
- ✅ Documentare la struttura nella root README
- ✅ NON creare file nella root se possono essere organizzati meglio
- ✅ NON mescolare tipi di file diversi nella stessa directory
- ✅ Mantenere `.gitignore` aggiornato per escludere file temporanei

### Struttura Consigliata

```
project/
├── app/                    # Codice applicazione principale
│   ├── routers/          # Endpoint API
│   ├── services/         # Logica di business
│   ├── models/           # Modelli database
│   └── config.py         # Configurazione
├── frontend/              # Frontend (se presente)
├── scripts/               # Script di utilità
│   ├── install/          # Script installazione
│   ├── backup/           # Script backup
│   └── migrate/           # Script migrazione
├── deploy/                # Script deployment
│   ├── docker/           # Dockerfiles e compose
│   └── proxmox/          # Script Proxmox
├── tests/                 # Test
│   ├── unit/             # Test unitari
│   └── integration/      # Test integrazione
├── docs/                  # Documentazione
├── backups/               # Backup (gitignored)
├── logs/                  # Log (gitignored)
├── config/                # File configurazione
├── .gitignore            # File da ignorare
├── .cursorrules          # Regole Cursor
└── README.md             # Documentazione principale
```

